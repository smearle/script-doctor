import bdb
import glob
import json
import os
import pickle
import random
import shutil
import traceback

from einops import rearrange
import hydra
import imageio
import jax
import jax.numpy as jnp
from lark import Lark
import numpy as np
from skimage.transform import resize

from conf.config import Config
from env import PSEnv
from gen_tree import GenPSTree
from parse_lark import TREES_DIR, DATA_DIR, TEST_GAMES, get_tree_from_txt
from ps_game import PSGameTree
from utils import to_binary_vectors
from utils_rl import get_env_params_from_config


scratch_dir = 'scratch'
os.makedirs(scratch_dir, exist_ok = True)


@hydra.main(version_base="1.3", config_path='./conf', config_name='config')
def main(config: Config):
    with open('data', 'games_n_rules.json', 'r') as f:
        games_n_rules = json.load(f)
    games_n_rules = sorted(games_n_rules, key=lambda x: x[1])
    games = [game for game, n_rules in games_n_rules]
    results = {
        'compile_error': [],
        'runtime_error': [],
        'solution_error': [],
        'state_error': [],
        'score_error': [],
        'success': [],
    }
    val_results_path = os.path.join('data', 'validation_results.json')
    if os.path.isfile(val_results_path):
        shutil.copy(val_results_path, val_results_path[:-5] + '_bkp.json')

    # tree_paths = [os.path.join(TREES_DIR, os.path.basename(path) + '.pkl') for path in sol_paths]
    # games = [os.path.basename(path)[:-4] for path in sol_paths]
    js_sols_dir = os.path.join('data', 'js_sols')
    jax_sols_dir = os.path.join('data', 'jax_sols')
    sol_paths = [os.path.join(js_sols_dir, game) for game in games]

    for sol_dir, game in zip(sol_paths, games):
        jax_sol_dir = os.path.join(jax_sols_dir, game)
        os.makedirs(jax_sol_dir, exist_ok=True)
        compile_log_path = os.path.join(jax_sol_dir, 'compile_err.txt')
        if os.path.exists(compile_log_path) and not config.overwrite:
            results['compile_error'].append(game)
            print(f"Skipping {game} because compile error log already exists")
            continue

        with open("syntax.lark", "r", encoding='utf-8') as file:
            puzzlescript_grammar = file.read()
        # Initialize the Lark parser with the PuzzleScript grammar
        parser = Lark(puzzlescript_grammar, start="ps_game", maybe_placeholders=False)
        # min_parser = Lark(min_puzzlescript_grammar, start="ps_game")
        tree, success, err_msg = get_tree_from_txt(parser, game)
        og_path = os.path.join(DATA_DIR, 'scraped_games', os.path.basename(game) + '.txt')

        print(f"Processing solution for game: {og_path}")

        try:
            env = PSEnv(tree)
        except KeyboardInterrupt as e:
            raise e
        except bdb.BdbQuit as e:
            raise e
        except Exception as e:
            err_log = traceback.format_exc()
            with open(os.path.join(jax_sol_dir, 'error.txt'), 'w') as f:
                f.write(err_log)
            traceback.print_exc()
            print(f"Error creating env: {og_path}")
            results['compile_error'].append(og_path)
            continue

        key = jax.random.PRNGKey(0)
        params = get_env_params_from_config(env, config)

        # 0 - left
        # 1 - down
        # 2 - right
        # 3 - up
        # 4 - action
        action_remap = [3, 0, 1, 2, 4]

        key = jax.random.PRNGKey(0)

        # Get all level solutions previously generated by tree search in javascript.
        level_sols = glob.glob(os.path.join(sol_dir, 'level-*.json'))

        for level_sol_path in level_sols:
            level_i = int(os.path.basename(level_sol_path).split('-')[1].split('.')[0])
            sol_log_path = os.path.join(jax_sol_dir, f'level-{level_i}_solution_err.txt')
            score_log_path = os.path.join(jax_sol_dir, f'level-{level_i}_score_err.txt')
            run_log_path = os.path.join(jax_sol_dir, f'level-{level_i}_runtime_err.txt')
            state_log_path = os.path.join(jax_sol_dir, f'level-{level_i}_state_err.txt')
            gif_path = os.path.join(jax_sol_dir, f'level-{level_i}.gif')
            if (os.path.exists(gif_path) or os.path.exists(sol_log_path) or os.path.exists(score_log_path) \
                    or os.path.exists(run_log_path) or os.path.exists(state_log_path)) and not config.overwrite:
                if os.path.exists(run_log_path):
                    results['runtime_error'].append((og_path, level_i))
                elif os.path.exists(sol_log_path):
                    results['solution_error'].append((og_path, level_i))
                elif os.path.exists(score_log_path):
                    results['score_error'].append((og_path, level_i))
                elif os.path.exists(state_log_path):
                    results['state_error'].append((og_path, level_i))
                else:
                    results['success'].append((og_path, level_i))
                print(f"Skipping level {level_i} because gif or error log already exists")
                continue

            with open(level_sol_path, 'r') as f:
                sol_dict = json.load(f)
            level_sol = sol_dict['sol']
            level_win = sol_dict['won']
            level_score = sol_dict['score']
            level_state = sol_dict['state']
            obj_list = sol_dict['objs']
            level_state = np.array(level_state).T
            level_multihot = to_binary_vectors(level_state, len(obj_list))
            level_multihot = rearrange(level_multihot, 'h w c -> c h w')
            level_multihot = np.flip(level_multihot, 0)
            actions = level_sol
            actions = [action_remap[a] for a in actions]
            actions = jnp.array([int(a) for a in actions])


            js_gif_path = os.path.join(sol_dir, f'level-{level_i}_sol.gif')
            level = env.get_level(level_i)
            params = params.replace(level=level)
            print(f"Level {level_i} solution: {actions}")

            def step_env(state, action):
                obs, state, reward, done, info = env.step_env(key, state, action, params)
                return state, state

            try:
                obs, state = env.reset(key, params)
                state, state_v = jax.lax.scan(step_env, state, actions)
                if level_win and not state.win:
                # if not done:
                    with open(sol_log_path, 'w') as f:
                        f.write(f"Level {level_i} solution failed\n")
                        f.write(f"Actions: {actions}\n")
                        results['solution_error'].append((og_path, level_i))
                        # f.write(f"State: {state}\n")
                    print(f"Level {level_i} solution failed")
                elif np.any(level_multihot != state.multihot_level):
                    js_state = state.replace(multihot_level=level_multihot)
                    js_frame = env.render(js_state, cv2=False)
                    js_frame = np.array(js_frame, dtype=np.uint8)
                    imageio.imsave(os.path.join(jax_sol_dir, f'level-{level_i}_state_js.png'), js_frame)
                    jax_frame = env.render(state, cv2=False)
                    jax_frame = np.array(jax_frame, dtype=np.uint8)
                    imageio.imsave(os.path.join(jax_sol_dir, f'level-{level_i}_state_jax.png'), jax_frame)
                    with open(sol_log_path, 'w') as f:
                        f.write(f"Level {level_i} solution failed\n")
                        f.write(f"Actions: {actions}\n")
                        f.write(f"State: {state}\n")
                        results['state_error'].append((og_path, level_i))
                    print(f"Level {level_i} solution failed")
                else:
                    results['success'].append((og_path, level_i))
                    print(f"Level {level_i} solution succeeded")
                # # FIXME: There is a discrepancy between the way we compute scores in js (I actually don't understand
                # # how we're getting that number) and the way we compute scores in jax, so this will always fail.
                if not level_win and (state.heuristic != level_score):
                    with open(score_log_path, 'w') as f:
                        f.write(f"Level {level_i} solution score mismatch\n")
                        f.write(f"Actions: {actions}\n")
                        f.write(f"Jax score: {state.score}\n")
                        f.write(f"JS score: {level_score}\n")
                        results['score_error'].append((og_path, level_i))
            except Exception as e:
                traceback.print_exc()
                print(f"Error running solution: {og_path}")
                err_log = traceback.format_exc()
                results['runtime_error'].append((og_path, level_i))
                with open(run_log_path, 'w') as f:
                    f.write(err_log)
                continue

            # Use jax tree map to add the initial state
            state_v = jax.tree.map(lambda x, y: jnp.concatenate([x[None], y]), state, state_v)

            frames = jax.vmap(env.render, in_axes=(0, None))(state_v, None)
            frames = frames.astype(np.uint8)

            # Scale up the frames
            print(f"Scaling up frames for level {level_i}")
            scale = 10
            frames = jnp.repeat(frames, scale, axis=1)
            frames = jnp.repeat(frames, scale, axis=2)

            # Save the frames
            print(f"Saving frames for level {level_i}")
            frames_dir = os.path.join(jax_sol_dir, 'frames')
            os.makedirs(frames_dir, exist_ok=True)
            for i, js_frame in enumerate(frames):
                imageio.imsave(os.path.join(frames_dir, f'level-{level_i}_sol_{i:03d}.png'), js_frame)

            # Make a gif out of the frames
            imageio.mimsave(gif_path, frames, duration=0.1, loop=0)

            # Copy over the js gif
            shutil.copy(js_gif_path, os.path.join(jax_sol_dir, f'level-{level_i}_js.gif'))

        with open(val_results_path, 'w') as f:
            json.dump(results, f, indent=4)


    print(f"Finished validating solutions in jax.")


if __name__ == '__main__':
    main()